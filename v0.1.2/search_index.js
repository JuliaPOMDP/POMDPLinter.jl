var documenterSearchIndex = {"docs":
[{"location":"specifying_requirements/#specifying_requirements","page":"Specifying Requirements","title":"Specifying Requirements","text":"","category":"section"},{"location":"specifying_requirements/#Purpose","page":"Specifying Requirements","title":"Purpose","text":"","category":"section"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"When a researcher or student wants to use a solver in the POMDPs ecosystem, the first question they will ask is \"What do I have to implement to use this solver?\". The requirements interface provides a standard way for solver writers to answer this question.","category":"page"},{"location":"specifying_requirements/#Internal-interface","page":"Specifying Requirements","title":"Internal interface","text":"","category":"section"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"The most important functions in the requirements interface are get_requirements, check_requirements, and show_requirements.","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"get_requirements(f::Function, args::Tuple{...}) should be implemented by a solver or simulator writer for all important functions that use the POMDPs.jl interface. In practice, this function will rarely by implemented directly because the @POMDP_require macro automatically creates it. The function should return a RequirementSet object containing all of the methods POMDPs.jl functions that need to be implemented for the function to work with the specified arguments.","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"check_requirements returns true if all of the requirements in a RequirementSet are met, and show_requirements prints out a list of the requirements in a RequirementSet and indicates which ones have been met.","category":"page"},{"location":"specifying_requirements/#pomdp_require_section","page":"Specifying Requirements","title":"@POMDP_require","text":"","category":"section"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"The @POMDP_require macro is the main point of interaction with the requirements system for solver writers. It uses a special syntax to automatically implement get_requirements. This is best shown by example. Consider this @POMDP_require block from the DiscreteValueIteration package:","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"@POMDP_require solve(solver::ValueIterationSolver, mdp::Union{MDP,POMDP}) begin\n    M = typeof(mdp)\n    S = statetype(mdp)\n    A = actiontype(mdp)\n    @req discount(::M)\n    @subreq ordered_states(mdp)\n    @subreq ordered_actions(mdp)\n    @req transition(::M,::S,::A)\n    @req reward(::M,::S,::A,::S)\n    @req stateindex(::M,::S)\n    as = actions(mdp)\n    ss = states(mdp)\n    s = first(ss)\n    a = first(as)\n    dist = transition(mdp, s, a)\n    D = typeof(dist)\n    @req support(::D)\n    @req pdf(::D,::S)\nend","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"The first expression argument to the macro is a function signature specifying what the requirements apply to. The above example implements get_requirements{P<:Union{POMDP,MDP}}(solve::typeof(solve), args::Tuple{ValueIterationSolver,P}) which will construct a RequirementSet containing the requirements for executing the solve function with ValueIterationSolver and MDP or POMDP arguments at runtime.","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"The second expression is a begin-end block that specifies the requirements. The arguments in the function signature (solver and mdp in this example) may be used within the block.","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"The @req macro is used to specify a required function. Each @req should be followed by a function with the argument types specified. The @subreq macro is used to denote that the requirements of another function are also required. Each @subreq should be followed by a function call.","category":"page"},{"location":"specifying_requirements/#requirements_info","page":"Specifying Requirements","title":"requirements_info","text":"","category":"section"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"While the @POMDP_require macro is used to specify requirements for a specific method, the requirements_info function is a more flexible communication tool for a solver writer. requirements_info should print out a message describing the requirements for a solver. The exact form of the message is up to the solver writer, but it should be carefully thought-out because problem-writers will be directed to call the function (via the @requirements_info macro) as the first step in using a new solver.","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"By default, requirements_info calls show_requirements on the solve function. This is adequate in many cases, but in some cases, notably for online solvers such as MCTS, the requirements for solve do not give a good indication of the requirements for using the solver. Instead, the requirements for action should be displayed. The following example shows a more informative version of requirements_info from the MCTS package. Since action requires a state argument, requirements_info prompts the user to provide one.","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"function POMDPs.requirements_info(solver::AbstractMCTSSolver, problem::Union{POMDP,MDP})\n    if statetype(typeof(problem)) <: Number\n        s = one(statetype(typeof(problem)))\n        requirements_info(solver, problem, s)\n    else\n        println(\"\"\"\n            Since MCTS is an online solver, most of the computation occurs in `action(policy, state)`. In order to view the requirements for this function, please, supply a state as the third argument to `requirements_info`, e.g.\n\n                @requirements_info $(typeof(solver))() $(typeof(problem))() $(statetype(typeof(problem)))()\n\n                \"\"\")\n    end\nend\n\nfunction POMDPs.requirements_info(solver::AbstractMCTSSolver, problem::Union{POMDP,MDP}, s)\n    policy = solve(solver, problem)\n    requirements_info(policy, s)\nend\n\nfunction POMDPs.requirements_info(policy::AbstractMCTSPolicy, s)\n    @show_requirements action(policy, s)\nend","category":"page"},{"location":"specifying_requirements/#@warn_requirements","page":"Specifying Requirements","title":"@warn_requirements","text":"","category":"section"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"The @warn_requirements macro is a useful tool to improve usability of a solver. It will show a requirements list only if some requirements are not met. It might be used, for example, in the solve function to give a problem writer a useful error if some required methods are missing (assuming the solver writer has already used @POMDP_require to specify the requirements for solve):","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"function solve(solver::ValueIterationSolver, mdp::Union{POMDP, MDP})\n    @warn_requirements solve(solver, mdp)\n\n    # do the work of solving\nend","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"@warn_requirements does perform a runtime check of requirements every time it is called, so it should not be used in code that may be used in fast, high-performance loops.","category":"page"},{"location":"specifying_requirements/#implemented_section","page":"Specifying Requirements","title":"Determining whether a function is implemented","text":"","category":"section"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"When checking requirements in check_requirements, or printing in show_requirements, the implemented function is used to determine whether an implementation for a function is available. For example implemented(discount, Tuple{NewPOMDP}) should return true if the writer of the NewPOMDP problem has implemented discount for their problem. In most cases, the default implementation,","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"implemented(f::Function, TT::TupleType) = method_exists(f, TT)","category":"page"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"will automatically handle this, but there may be cases in which you want to override the behavior of implemented, for example, if the function can be synthesized from other functions. Examples of this can be found in the default implementations of the generative interface funcitons.","category":"page"},{"location":"specifying_requirements/#API","page":"Specifying Requirements","title":"API","text":"","category":"section"},{"location":"specifying_requirements/","page":"Specifying Requirements","title":"Specifying Requirements","text":"implemented\n@implemented\ncheck_requirements\nshow_requirements\nget_requirements\nrequirements_info\n@POMDP_require\n@POMDP_requirements\n@warn_requirements\n@req\n@subreq","category":"page"},{"location":"specifying_requirements/#POMDPLinter.implemented","page":"Specifying Requirements","title":"POMDPLinter.implemented","text":"implemented(function, Tuple{Arg1Type, Arg2Type})\n\nCheck whether there is an implementation available that will return a suitable value.\n\n\n\n\n\n","category":"function"},{"location":"specifying_requirements/#POMDPLinter.@implemented","page":"Specifying Requirements","title":"POMDPLinter.@implemented","text":"@implemented function(::Arg1Type, ::Arg2Type)\n\nCheck whether there is an implementation available that will return a suitable value.\n\n\n\n\n\n","category":"macro"},{"location":"specifying_requirements/#POMDPLinter.check_requirements","page":"Specifying Requirements","title":"POMDPLinter.check_requirements","text":"check_requirements(r::AbstractRequirementSet)\n\nCheck whether the methods in r have implementations with implemented(). Return true if all methods have implementations.\n\n\n\n\n\n","category":"function"},{"location":"specifying_requirements/#POMDPLinter.show_requirements","page":"Specifying Requirements","title":"POMDPLinter.show_requirements","text":"show_requirements(r::AbstractRequirementSet)\n\nCheck whether the methods in r have implementations with implemented() and print out a formatted list showing which are missing. Return true if all methods have implementations.\n\n\n\n\n\n","category":"function"},{"location":"specifying_requirements/#POMDPLinter.get_requirements","page":"Specifying Requirements","title":"POMDPLinter.get_requirements","text":"get_requirements(f::Function, args::Tuple)\n\nReturn a RequirementSet for the function f and arguments args.\n\n\n\n\n\n","category":"function"},{"location":"specifying_requirements/#POMDPLinter.requirements_info","page":"Specifying Requirements","title":"POMDPLinter.requirements_info","text":"requirements_info(s::Union{Solver, Simulator}, p::Union{POMDP,MDP}, ...)\n\nPrint information about the requirement for solver s.\n\n\n\n\n\n","category":"function"},{"location":"specifying_requirements/#POMDPLinter.@POMDP_require","page":"Specifying Requirements","title":"POMDPLinter.@POMDP_require","text":"@POMDP_require solve(s::CoolSolver, p::POMDP) begin\n    PType = typeof(p)\n    @req states(::PType)\n    @req actions(::PType)\n    @req transition(::PType, ::S, ::A)\n    s = first(states(p))\n    a = first(actions(p))\n    t_dist = transition(p, s, a)\n    @req rand(::AbstractRNG, ::typeof(t_dist))\nend\n\nCreate a get_requirements implementation for the function signature and the requirements block.\n\n\n\n\n\n","category":"macro"},{"location":"specifying_requirements/#POMDPLinter.@POMDP_requirements","page":"Specifying Requirements","title":"POMDPLinter.@POMDP_requirements","text":"reqs = @POMDP_requirements CoolSolver begin\n    PType = typeof(p)\n    @req states(::PType)\n    @req actions(::PType)\n    @req transition(::PType, ::S, ::A)\n    s = first(states(p))\n    a = first(actions(p))\n    t_dist = transition(p, s, a)\n    @req rand(::AbstractRNG, ::typeof(t_dist))\nend\n\nCreate a RequirementSet object.\n\n\n\n\n\n","category":"macro"},{"location":"specifying_requirements/#POMDPLinter.@warn_requirements","page":"Specifying Requirements","title":"POMDPLinter.@warn_requirements","text":"@warn_requirements solve(solver, problem)\n\nPrint a warning if there are unmet requirements.\n\n\n\n\n\n","category":"macro"},{"location":"specifying_requirements/#POMDPLinter.@req","page":"Specifying Requirements","title":"POMDPLinter.@req","text":"@req f( ::T1, ::T2)\n\nConvert a f( ::T1, ::T2) expression to a (f, Tuple{T1,T2})::Req for pushing to a RequirementSet.\n\nIf in a @POMDP_requirements or @POMDP_require block, marks the requirement for including in the set of requirements.\n\n\n\n\n\n","category":"macro"},{"location":"specifying_requirements/#POMDPLinter.@subreq","page":"Specifying Requirements","title":"POMDPLinter.@subreq","text":"@subreq f(arg1, arg2)\n\nIn a @POMDP_requirements or @POMDP_require block, include the requirements for f(arg1, arg2) as a child argument set.\n\n\n\n\n\n","category":"macro"},{"location":"requirements/#requirements","page":"Viewing Requirements","title":"Viewing Requirements for Problems","text":"","category":"section"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"Due to the large variety of problems that can be expressed as MDPs and POMDPs and the wide variety of solution techniques available, there is considerable variation in which of the POMDPs.jl interface functions must be implemented to use each solver. No solver requires all of the functions in the interface, so it is wise to determine which functions are needed before jumping into implementation.","category":"page"},{"location":"requirements/#Showing-Requirements","page":"Viewing Requirements","title":"Showing Requirements","text":"","category":"section"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"Some solvers communicate these requirements through the @requirements_info and @show_requirements macros. @requirements_info should give an overview of the requirements for a solver, which is supplied as the first argument, the macro can usually be more informative if a problem is specified as the second arg. For example, if you are implementing a new problem NewMDP and want to use the DiscreteValueIteration solver, you might run the following:","category":"page"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"(Image: requirements_info for a new problem)","category":"page"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"Note that a few of the requirements could not be shown because actions is not implemented for the new problem.","category":"page"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"If you would like to see a list of all of the requirements for a solver, try running @requirements_info with a fully implemented model from POMDPModels, for example,","category":"page"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"(Image: requirements_info for a fully-implemented problem)","category":"page"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"@show_requirements is a lower-level tool that can be used to show the requirements for a specific function call, for example","category":"page"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"@show_requirements solve(ValueIterationSolver(), NewMDP())","category":"page"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"or","category":"page"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"policy = solve(ValueIterationSolver(), GridWorld())\n@show_requirements action(policy, GridWorldState(1,1))","category":"page"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"In some cases, a solver writer may not have specified the requirements, in which case the requirements query macros will output","category":"page"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"[No requirements specified]","category":"page"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"In this case, please file an issue on the solver's github page to encourage the solver writer to specify requirements.","category":"page"},{"location":"requirements/#API","page":"Viewing Requirements","title":"API","text":"","category":"section"},{"location":"requirements/","page":"Viewing Requirements","title":"Viewing Requirements","text":"@get_requirements\n@show_requirements\n@requirements_info","category":"page"},{"location":"requirements/#POMDPLinter.@get_requirements","page":"Viewing Requirements","title":"POMDPLinter.@get_requirements","text":"@get_requirements f(arg1, arg2)\n\nCall get_requirements(f, (arg1,arg2)).\n\n\n\n\n\n","category":"macro"},{"location":"requirements/#POMDPLinter.@show_requirements","page":"Viewing Requirements","title":"POMDPLinter.@show_requirements","text":"@show_requirements solve(solver, problem)\n\nPrint a a list of requirements for a function call.\n\n\n\n\n\n","category":"macro"},{"location":"requirements/#POMDPLinter.@requirements_info","page":"Viewing Requirements","title":"POMDPLinter.@requirements_info","text":"@requirements_info ASolver() [YourPOMDP()]\n\nPrint information about the requirements for a solver.\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = POMDPLinter","category":"page"},{"location":"#POMDPLinter","page":"Home","title":"POMDPLinter","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, the POMDPLinter package only contains tools for specifying and viewing interface requirements for a particular solver.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
